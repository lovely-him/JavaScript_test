/* Pulse counter module - Example

   For other examples please check:
   https://github.com/espressif/esp-idf/tree/master/examples

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/portmacro.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "driver/periph_ctrl.h"
#include "driver/ledc.h"
#include "driver/gpio.h"
#include "driver/pcnt.h"
#include "esp_attr.h"
#include "esp_log.h"

/* 这个例子使用脉冲计数器模块(PCNT)来计算由LED控制器模块(LEDC)产生的PWM脉冲的上升边缘。 */

/**
 * TEST CODE BRIEF
 *
 * Use PCNT module to count rising edges generated by LEDC module.
 *
 * Functionality of GPIOs used in this example:
 *   - GPIO18 - output pin of a sample 1 Hz pulse generator,
 *   - GPIO4 - pulse input pin,
 *   - GPIO5 - control input pin.
 *
 * Load example, open a serial port to view the message printed on your screen.
 *
 * To do this test, you should connect GPIO18 with GPIO4.
 * GPIO5 is the control signal, you can leave it floating with internal pull up,
 * or connect it to ground. If left floating, the count value will be increasing.
 * If you connect GPIO5 to GND, the count value will be decreasing.
 *
 * An interrupt will be triggered when the counter value:
 *   - reaches 'thresh1' or 'thresh0' value,
 *   - reaches 'l_lim' value or 'h_lim' value,
 *   - will be reset to zero.
 */
#define PCNT_TEST_UNIT      PCNT_UNIT_0
#define PCNT_H_LIM_VAL      100
#define PCNT_L_LIM_VAL     -100
#define PCNT_THRESH1_VAL    50
#define PCNT_THRESH0_VAL   -50
#define PCNT_INPUT_SIG_IO   15  // Pulse Input GPIO 脉冲输入GPIO
#define PCNT_INPUT_CTRL_IO  4  // Control GPIO HIGH=count up, LOW=count down 控制GPIO
#define LEDC_OUTPUT_IO      5 // Output GPIO of a sample 1 Hz pulse generator 输出一个采样1hz脉冲发生器的GPIO

xQueueHandle pcnt_evt_queue;   // A queue to handle pulse counter events 处理脉冲计数器事件的队列
pcnt_isr_handle_t user_isr_handle = NULL; //user's ISR service handle 用户的ISR服务句柄

/* A sample structure to pass events from the PCNT 从PCNT传递事件的示例结构
 * interrupt handler to the main program. 主程序的中断处理程序。
 */
typedef struct {
    int unit;  // the PCNT unit that originated an interrupt 触发中断的PCNT单元
    uint32_t status; // information on the event type that caused the interrupt 有关导致中断的事件类型的信息
} pcnt_evt_t;

/* Decode what PCNT's unit originated an interrupt 解码PCNT的设备发出的中断
 * and pass this information together with the event type 并将此信息与事件类型一起传递
 * the main program using a queue. 使用队列的主程序。
 */
static void IRAM_ATTR pcnt_example_intr_handler(void *arg)
{
    uint32_t intr_status = PCNT.int_st.val;     // 直接取了寄存器的地址？ 这是 中断的屏蔽中断状态位 寄存器。
    int i;
    pcnt_evt_t evt;
    portBASE_TYPE HPTaskAwoken = pdFALSE;

    for (i = 0; i < PCNT_UNIT_MAX; i++) {
        if (intr_status & (BIT(i))) {           // 查看哪个单元开启了中断？？
            evt.unit = i;
            /* Save the PCNT event type that caused an interrupt 保存引起中断的PCNT事件类型
               to pass it to the main program 把它传递给主程序 */ 
            evt.status = PCNT.status_unit[i].val; // 把这个单元内的状态寄存器取出来
            PCNT.int_clr.val = BIT(i);              // 清楚中断标志位
            xQueueSendFromISR(pcnt_evt_queue, &evt, &HPTaskAwoken);     // 队列发送
            if (HPTaskAwoken == pdTRUE) {
                portYIELD_FROM_ISR();  // 如果数据已成功发送到队列，则执行pdTRUE，否则执行errQUEUE_FULL。？？
            }
        }
    }
}

/* Configure LED PWM Controller 配置LED PWM控制器
 * to output sample pulses at 1 Hz with duty of about 10% 输出1hz的采样脉冲，占空比约为10%
 */
static void ledc_init(void)
{
    // 准备然后应用LEDC PWM定时器配置
    // Prepare and then apply the LEDC PWM timer configuration
    ledc_timer_config_t ledc_timer;
    ledc_timer.speed_mode       = LEDC_LOW_SPEED_MODE;
    ledc_timer.timer_num        = LEDC_TIMER_1;
    ledc_timer.duty_resolution  = LEDC_TIMER_10_BIT;
    ledc_timer.freq_hz          = 1;  // set output frequency at 1 Hz 设置输出频率为1hz
    ledc_timer.clk_cfg = LEDC_AUTO_CLK;
    ledc_timer_config(&ledc_timer);

    // 准备然后应用LEDC PWM通道配置
    // Prepare and then apply the LEDC PWM channel configuration
    ledc_channel_config_t ledc_channel;
    ledc_channel.speed_mode = LEDC_LOW_SPEED_MODE;
    ledc_channel.channel    = LEDC_CHANNEL_1;
    ledc_channel.timer_sel  = LEDC_TIMER_1;
    ledc_channel.intr_type  = LEDC_INTR_DISABLE;
    ledc_channel.gpio_num   = LEDC_OUTPUT_IO;
    ledc_channel.duty       = 100; // set duty at about 10% 设定税率为10%左右
    ledc_channel.hpoint     = 0;
    ledc_channel_config(&ledc_channel);
}

/* Initialize PCNT functions: 初始化PCNT函数:
 *  - configure and initialize PCNT 配置和初始化PCNT
 *  - set up the input filter 设置输入过滤器
 *  - set up the counter events to watch 设置计数器事件观看
 */
static void pcnt_example_init(void)
{
    /*准备配置的PCNT单位*/
    /* Prepare configuration for the PCNT unit */
    pcnt_config_t pcnt_config = {
        //设置PCNT输入信号和控制gpio
        // Set PCNT input signal and control GPIOs
        .pulse_gpio_num = PCNT_INPUT_SIG_IO,
        .ctrl_gpio_num = PCNT_INPUT_CTRL_IO,
        .channel = PCNT_CHANNEL_0,
        .unit = PCNT_TEST_UNIT,
        //在脉冲输入的正/负边缘上做什么?
        // What to do on the positive / negative edge of pulse input?
        .pos_mode = PCNT_COUNT_INC,   // Count up on the positive edge 数一数积极的一面
        .neg_mode = PCNT_COUNT_DIS,   // Keep the counter value on the negative edge 保持计数器值在负边缘
        //当控制输入低或高时怎么办?
        // What to do when control input is low or high?
        .lctrl_mode = PCNT_MODE_REVERSE, // Reverse counting direction if low 如果计数方向低，则反向计数
        .hctrl_mode = PCNT_MODE_KEEP,    // Keep the primary counter mode if high 如果高，则保持主计数器模式
        //设置最大和最小限制值来监视
        // Set the maximum and minimum limit values to watch
        .counter_h_lim = PCNT_H_LIM_VAL,
        .counter_l_lim = PCNT_L_LIM_VAL,
    };
    /*初始化PCNT单元*/
    /* Initialize PCNT unit */
    pcnt_unit_config(&pcnt_config);

    /*配置和启用输入过滤器*/
    /* Configure and enable the input filter */
    pcnt_set_filter_value(PCNT_TEST_UNIT, 100);
    pcnt_filter_enable(PCNT_TEST_UNIT);

    /*设置阈值0和1，并启用事件监视*/
    /* Set threshold 0 and 1 values and enable events to watch */
    pcnt_set_event_value(PCNT_TEST_UNIT, PCNT_EVT_THRES_1, PCNT_THRESH1_VAL);
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_THRES_1);
    pcnt_set_event_value(PCNT_TEST_UNIT, PCNT_EVT_THRES_0, PCNT_THRESH0_VAL);
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_THRES_0);
    /*在0，最大和最小限值上启用事件*/
    /* Enable events on zero, maximum and minimum limit values */
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_ZERO);
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_H_LIM);
    pcnt_event_enable(PCNT_TEST_UNIT, PCNT_EVT_L_LIM);

    /*初始化PCNT的计数器*/
    /* Initialize PCNT's counter */
    pcnt_counter_pause(PCNT_TEST_UNIT);
    pcnt_counter_clear(PCNT_TEST_UNIT);

    /*为PCNT单元注册ISR处理程序并启用中断*/
    /* Register ISR handler and enable interrupts for PCNT unit */
    pcnt_isr_register(pcnt_example_intr_handler, NULL, 0, &user_isr_handle);
    pcnt_intr_enable(PCNT_TEST_UNIT);

    /*所有的设置，现在去计数*/
    /* Everything is set up, now go to counting */
    pcnt_counter_resume(PCNT_TEST_UNIT);
}

void app_main(void)
{
    /*初始化LEDC产生采样脉冲信号*/
    /* Initialize LEDC to generate sample pulse signal */
    ledc_init();

    /* 初始化PCNT事件队列和PCNT函数 */ 
    /* Initialize PCNT event queue and PCNT functions */
    pcnt_evt_queue = xQueueCreate(10, sizeof(pcnt_evt_t));
    pcnt_example_init();

    int him_add = 0;
    int16_t count = 0;
    pcnt_evt_t evt;
    portBASE_TYPE res;
    while (1) {
        /* Wait for the event information passed from PCNT's interrupt handler.
         * Once received, decode the event type and print it on the serial monitor.
         */
        /* 等待事件信息从PCNT的中断处理程序传递。
        *  一旦收到，解码事件类型，并打印在串行监视器上。
        */
        res = xQueueReceive(pcnt_evt_queue, &evt, 5 / portTICK_PERIOD_MS);
        if (res == pdTRUE) {
            pcnt_get_counter_value(PCNT_TEST_UNIT, &count);
            printf("Event PCNT unit[%d]; cnt: %d\n", evt.unit, count+him_add);
            if (evt.status & PCNT_EVT_THRES_1) {
                // printf("THRES1 EVT\n");
            }
            if (evt.status & PCNT_EVT_THRES_0) {
                // printf("THRES0 EVT\n");
            }
            if (evt.status & PCNT_EVT_L_LIM) {
                // printf("L_LIM EVT\n");
                him_add += PCNT_L_LIM_VAL;
            }
            if (evt.status & PCNT_EVT_H_LIM) {
                // printf("H_LIM EVT\n");
                him_add += PCNT_H_LIM_VAL;
            }
            if (evt.status & PCNT_EVT_ZERO) {
                // printf("ZERO EVT\n");
            }
        } else {
            pcnt_get_counter_value(PCNT_TEST_UNIT, &count);
            printf("Current counter value :%d\n", count+him_add);
        }
    }
    if(user_isr_handle) {
        //释放ISR服务句柄。 （正常不会进来吧）
        //Free the ISR service handle.
        esp_intr_free(user_isr_handle);
        user_isr_handle = NULL;
    }
}
